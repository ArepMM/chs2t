#include "dako.h"

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
Dako::Dako(QObject* parent) : Device(parent)
  , V0(0.0005)
  , V1(0.0005)
  , U1(40.0)
  , U6(80.0)
  , wheel_r(0.625)
  , w1(U1 / Physics::kmh / wheel_r)
  , w1_cur(0.0)
  , w6(U6 / Physics::kmh / wheel_r)
  , w6_cur(0.0)
  , pFL(0.0)
  , pBC(0.0)
  , QFL(0.0)
  , QBC(0.0)
  , A1(0.71)
  , A2(1.0)
  , K1(1.0e-2)
  , K2(1.5e-2)
  , K3(3.0e-3)
  , K4(4.0e-3)
  , K5(4.0e-3)
  , k_1(2.0)
  , k_2(2.0)
  , k_3(10.0)
  , k_4(10.0)
  , EDT_state(false)
{

}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
Dako::~Dako()
{

}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::setWheelRadius(double value)
{
    wheel_r = value;
    w1 = U1 / wheel_r / Physics::kmh;
    w6 = U6 / wheel_r / Physics::kmh;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::setAngularVelocity1(double value)
{
    w1_cur = abs(value);
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::setAngularVelocity6(double value)
{
    w6_cur = abs(value);
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::setFLpressure(double value)
{
    pFL = value;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
double Dako::getFLflow() const
{
    return QFL;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::setBCpressure(double value)
{
    pBC = value;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
double Dako::getBCflow() const
{
    return QBC;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::setLocoCranePressure(double value)
{
    pKVT = value;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::setAirDistPressure(double value)
{
    pAD = value;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
bool Dako::isEDTAllow() const
{
    return EDT_state;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::ode_system(const state_vector_t& Y, state_vector_t& dYdt, double t)
{
    Q_UNUSED(t)

    // Управление нижней камерой от центробежного регулятора на шестой оси
    double s0 = w6_cur - w6;

    // Наполнение нижней камеры вслед за давлением от КВТ и экстренного торможения
    double Q0 = cut(k_3 * s0, 0.0, K3) * (pKVT - Y[DACO_BOTTOM_CAMERA]);
    // Опорожнение нижней камеры
    double Q0_atm = cut(-k_4 * s0, 0.0, K4) * Y[DACO_BOTTOM_CAMERA];

    // Наполнение и опорожнение средней камеры вслед за давлением от воздухораспределителя
    double Q1 = K5 * (pAD - Y[DACO_MIDDLE_CAMERA]);

    dYdt[DACO_BOTTOM_CAMERA] = (Q0 - Q0_atm) / V0;

    dYdt[DACO_MIDDLE_CAMERA] = Q1 / V1;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::preStep(state_vector_t& Y, double t)
{
    Q_UNUSED(Y)
    Q_UNUSED(t)

    // Равновесие диафрагм - условное положение центрального штока
    double sA = A1 * Y[DACO_BOTTOM_CAMERA] + A2 * Y[DACO_MIDDLE_CAMERA] - pBC;
    // Поток на наполнение ТЦ из питательной магистрали
    double Q_fl_bc = cut(k_1 * sA, 0.0, K1) * (pFL - pBC);
    // Поток на опорожнение ТЦ в атмосферу
    double Q_bc_atm = cut(-k_2 * sA, 0.0, K2) * pBC;

    // Поток в тормозные цилиндры
    QBC = Q_fl_bc - Q_bc_atm;

    // Поток в питательную магистраль
    QFL = -Q_fl_bc;

    // Разрешение реостатного тормоза от центробежного регулятора на первой оси
    EDT_state = (w1_cur >= w1);
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void Dako::load_config(CfgReader& cfg)
{
    QString secName = "Device";

    cfg.getDouble(secName, "V0", V0);
    cfg.getDouble(secName, "V1", V1);

    cfg.getDouble(secName, "U1", U1);
    cfg.getDouble(secName, "U6", U6);
    w1 = U1 / wheel_r / Physics::kmh;
    w6 = U6 / wheel_r / Physics::kmh;

    cfg.getDouble(secName, "A1", A1);
    cfg.getDouble(secName, "A2", A2);

    cfg.getDouble(secName, "K1", K1);
    cfg.getDouble(secName, "K2", K2);
    cfg.getDouble(secName, "K3", K3);
    cfg.getDouble(secName, "K4", K4);
    cfg.getDouble(secName, "K5", K5);

    cfg.getDouble(secName, "k1", k_1);
    cfg.getDouble(secName, "k2", k_2);
    cfg.getDouble(secName, "k3", k_3);
    cfg.getDouble(secName, "k4", k_4);
}
